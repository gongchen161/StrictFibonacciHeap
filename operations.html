<!DOCTYPE html>

<html>
	
	<head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Strict Fibonacci Heap</title>
        <script src="d3.js"></script>
        <link rel="stylesheet" href="styles.css">
    </head>

    <body>

    <div id ="nav">
      <ul>
         <li><a href="index.html" title="Home">OVERVIEW</a></li>
         <li><a href="definitions.html" title="Home">DEFINITIONS</a></li>
         <li><a href="invariants.html" title="Home">INVARIANTS</a></li>
         <li><a href="transformations.html" title="Home">TRANSFORMATIONS</a></li>
         <li><a href="operations.html" title="Home">OPERATIONS</a></li>
         <li><a href="demo.html" title="Home">DEMO</a></li>
      </ul>
    </div>
 

    <div id ="title">
      <h1>Operations</h1> 
    </div>

    <div id ="body">
     
     <fieldset>
        <h2>Report Min - O(1) Worst Case</h2>
        <ul>
          <li><h3>Trivially, Min always at the Root</h3></li>
        </ul>
     </fieldset>


        <fieldset>
        <h2>Decrease Key - O(1) Worst Case</h2>
        <h3>To decrease the key of node x to v</h3>
        <ol>
          <li>If x is the root - DONE</li>
          <li>If v is smaller than the root value, swap the two values</li>
          <li>Cut the subtree rooted at x and link it to the root</li>
          <li>Perform &le; 1 Loss Reduction</li>
          <li>Perform &le; 6 Active Root Reduction and &le; 4 Root Degree Reduction</li>
          <ul>
            <li>Note again, 3 Active Root Reduction + 2 Root Degree Reduction decreases both Root degree and Active Root numbers by 1. Since the violations could be broken by 1 at most, this step guarantees no violations afterward</li>
          </ul>
        </ol>

        <h3> Effects on Invariants</h4>
        <ul>
        <li>Invariant 1:</li>
        <p>This is trivially true as step 1 and 3 does not affect I1 at all and the transformations in step 4 and 5 does not cause violations(as explained before)</p>

         <li> Invariant 2:</li>
          <p>Let y be the parent of x, if y and x are both active nodes, then the total loss will increase by one and may cause I3 to be violated(total loss > R + 1). However,by Lemma 3, we are guaranteed be able to perform one loss reduction in step 4.</p>

         <li> Invariant 3:</li>
          <p>If x was active, the total number of active root may increase to R + 2. However, by Lemma 4, we are guaranteed be able to perform the reductions in step 5.</p>

         <li> Invariants 4:</li>
          <p>The root degree increases by 1 after adding x. If this makes the root degree to be R + 4(violation), then by Lemma 4, and perform the transformations in Step 5, we can bring down the root degree (and active node number)</p>


         <li> Invariants 5:</li>
           <p> No non-root nodes gets new nodes and no transformation will break this invariant.</p>
      </ul>
     </fieldset>



        <fieldset>
        <h2>Merge - O(1) Worst Case</h2>
        <img src="merge.png" style="float:left; max-width:50%">
        <h3> Assume we want to merge H1 and H2, where size of H1 &le; Size of H2</h3>
        <ol>
          <li>Make all nodes in H1 passive - Just change the active record that all nodes in H1 points to</li>
          <li>Link H1 and H2 such that the smaller root of H1 and H2 becomes the new root</li>
          <li>Set the new Q to be Q1 + larger Root of H1 and H2 + Q2 (note Qi is the Q for Hi)</li>
          <li>Perform 0 or 1 Active Root Reduction and  0 or 1 Root Degree Reduction</li>
        </ol>

        <h4> Effects on Invariants</h4>
        <ul>
        <li>Invariant 1:</li>
        <p>Trivially, no effects as no new active nodes are formed. </p>

        <li> Invariant 2:</li>
          <p>Trivially, no changes on loss </p>

         <li> Invariant 3:</li>
          <p>When we link the two heap, all active nodes in the smaller heap become passive, so number of active roots does not change and N (thus R) increases. </p>
          

         <li> Invariants 4:</li>
          <p>The root degree increases by 1 after the linking. If this makes the root degree to be R + 4, then from Lemma 5, we will perform the transformations in step 4 (instead of 0) </p>


         <li> Invariants 5:</li>
           <p> During the linking, one root node becomes a passive non-root node. However, it had at most <i>R + 3</i> nodes before by I4), and <i>R + 3 < 2 log(2N - p) + 9</i> for any p. - no violations </p>
           <p>
             All nodes in the smaller heap become passive, thus their degree constraints could go from + 10 to just +9. However, for the smaller heap, the new N is at least twice as big as before, and their position is unchanged in the new Q, thus the new constraint is actually increased by at least one - no violations
           </p>

           <p>
            All nodes in the larger heap remains their active/passive status and have their p pushed back by size Of Small Heap position, but N is also increased by the same size. So 2N - p actually increases and the constraints strengthened - no violations
           </p>
      </ul>
     </fieldset>


      <fieldset>
        <h2>Insert - O(1) Worst Case</h2>
        <img src="insert.png" style="float:left; max-width:50%">
        <h3> Assume we want to insert node x</h3>
        <ol>
          <li>Create one heap with a passive node x</li>
          <li>Merge it with the main heap</li>
        </ol>
      </fieldset>


      <fieldset>
        <h2>DeleteMin - O(LogN) Worst Case</h2>
        <img src="merge.png" style="float:left; max-width:50%">
        <ol>
          <li>Scan through the children of the root and find node x with the minimum value</li>
          <li>Make x passive</p></li>
          <li>Make all the other children of the root children of x.</li>
          <li>Remove x from Q, delete the original root and make x the new root.</li>

          <li>Do this twice: move the first node, y, in Q to the back. If y has two passive children, link both to the root.<</li>
          <li>Perform 0 or 1 Loss Reduction.</li>
          <li>Perform <i>O(LogN)</i> numbers of Active root reduction and Root Degree Reduction until none is possible.(Note we need at most O(LogN) times because every 2 Active root reduction + 3 Root Degree Reduction reduces root degree by 1, and the new root degree increases by at most <i>2logN + 12 + 4</i>, and Active Roots increses by at most R(by Lemma 2, x had at most R active children)</li>
        </ol>

        <h4> Effects on Invariants</h4>
        <ul>
        <li>Invariant 1:</li>
        <p>No violation since no new active nodes.</p>

         <li> Invariant 2:</li>
          <p>This could be violated because R is decreased due to N is decreased by 1. However, by Lemma 2, we can perform one loss reduction in step 6 to bring us back </p>

         <li> Invariant 3:</li>
          <p>Could be violated since the number of active roots remains the same but R decreases as N is decreased by 1. However, by Lemma 3, we can performed the transformations in step 7 to bring us back </p>
         

         <li> Invariants 4:</li>
          <p>Hold trivially as we perform step 7 <i>O(logN)</i>ÃŸ times until none is possible.
          </p>


         <li> Invariants 5:</li>
           <p> Since N is decreased, the constraints are strengthened. And this is why we perform step 5. By removing two nodes to the back, all the other nodes have p decreased by 2 or 3 (depends on if the node was before or after the old min node). Thus, The constraints remain valid for these nodes. 
           </p>

           <p>
            For the two nodes that are moved back to the Q, their constraints reduced from, i.e. for Node 1, <i>2log(2oldN - 1) + 9</i> to <i>2log(2oldN - 2 - (oldN - 2)) + 9. or decreased by 2. But if this is violating the rule, given it has <= R active nodes, it must have two passive nodes for us to link to the root. Otherwise, no violation.
           </p>
      </ul>
     </fieldset>


   

     
    </div>

    </body>

</html>